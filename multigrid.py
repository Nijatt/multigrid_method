'''
name: Nijat SHUKUROV
id: 188108**
--- ANKARA UNIVERSITY ----

                                 Introduction
This code represents the algorithm of solving boundary value second order differential equation
using Finite Difference method by my own way.

In finite difference method you divide the boundary in finite differences and solves the equation using proper ways.

But in this algorithm divides the boundary to nodes in every iteration. For example :

    For this program I will show the example of f''(x)=-x^2,
    f(0)=1 and f(1)=0 this is boundary condition. and 0<=x<=1

1st iteration:
    we take
    [0_________________1] ---> [x_0, x_1] (array representation)  and divide it in a way that to make it 3 nodes.
    [0.1______0.5______1] ---> [x_0, x_1, x_2]
    and dx=x[n]-x[n-1]
In the same way we can show second iteration

2nd iteration:
    [0.1__0.25__0.5__0.75__1] ---> [x_0, x_1, x_2, x_3 , x_4]
        and dx=x[n]-x[n-1]

This algorithm continue do the same thing over and over again till comes to iteration number which you defined.


'''


#Important packages..
import numpy as np
import matplotlib.pyplot as plt
import time

#Time packet used for checking time spent for every iteration and total program.
start = time.time() # start variable contains time in seconds.


# Example second order differential equations..
def d2_f_dx2(x):

    return -x**2

def d2_f_dx2_2(x):

    return -x**2+5*x**3+np.exp(x)

'''This one generates different arrays for different nodes
    '''


#===============================================================

nodes=3 # Initial node number which will be used in first iteration.
        # Then respectively it will be changed in every iteration by nodes=nodes*2+1

old_u=[0,0]
''' old_u Initial array for u(x) function values. This array will grow respected to nodes in every iteration.
    DEEP NOTE: There is a different u(x) function values array in loop. In every iteration program algorithm
    uses this array values for solving and finding new members and adds it to new_u array. Then old_u array variable
    copies this new_u values. It is a global variable '''

'''Main iteration loop for algorithm '''

for i in range(10):

    time_spent_for_iterations=time.time() #Inital time when iteration starts.

    x_Boundary_Value_inital=0
    x_Boundary_Value_final=1

    x=np.linspace(x_Boundary_Value_inital,x_Boundary_Value_final,nodes)
    # This array contains x values which generated by Boundary Values and nodes.
    # Array grows every iteraion respected to node values.

    dx=x[1]-x[0] # dx value which generated by array values itself. Also changes gets smaller every iteration.

    new_u=np.zeros(len(x))
    # new_u array is virtual array which generates every iteration with array length due to nodes.

    #Some prints for showing outcome of every iterion. ====
    print('run #',i)
    print('dx=',dx)
    print('f(x) array lenght: ',len(new_u))
    #======================================================


    solving_iteration=int((nodes-1)/2)

    for i in range(solving_iteration):
        '''This loop is important for solving this equation by finite difference method. And iteration numbers of this loop 
                generates by node number or due to x array length. It finds new members of u(x) values or old_u array adding them to new_u array.'''

        step = 1 * (i + 1)
        #step variable used for coping old_u arrays node values to new_u array.

        new_u[i+step]=(old_u[i]+old_u[i+1]-d2_f_dx2(x[i+step])*(dx)**2)/2
        ''' f''(x)*dx^2=f(x+1)-2*f(x)+f(x-1) '''
        ''' f(x)= [f(x+1)+f(x-1)-f''(x)]/dx^2 '''
        new_u[i+step-1]=old_u[i]

        #End of iteration


    old_u=new_u #Copy new_u values to global variable old_u array


    for it in range(len(old_u)-2):
        '''This loops is making error smaller every main iteration, number of this loop is dependent on old_u array length '''

        for i in range(len(old_u)-3):
            old_u[i+2]=(old_u[i+1]+old_u[i+3]-d2_f_dx2(x[i+2])*(dx)**2)/2
        #end of loop..
        for i in range(len(old_u)-2):
            old_u[i+1]=(old_u[i]+old_u[i+2]-d2_f_dx2(x[i+1])*(dx)**2)/2
        #end of loop..

    #end of loop..

    nodes = nodes*2-1 #Generating nodes in every main iteration..

    # This prints time spent for iteration.
    print("Time",time.time()-time_spent_for_iterations," seconds")
    print('---------------------------')
#End of main loop..


# Analytic method

def f(x):
    return -(x**4)/12+(x/12)

def f2(x):
    return (-x**4)/12 + (x**5)/(4) +np.exp(x)+ (-2/12-np.exp(1)+1)*x-1

# array for u(x) numbers which found by analytic method...
analytic=[]
for i in range(len(x)):
       analytic.append(f(x[i]))


# Plots analytic method outcome
analy,=plt.plot(x,analytic,color="r",label="Analytic")

# Plots numerical method outcome
numeric,=plt.plot(x,old_u,color='g',label="Numerical")

#Print for error..
print("Maximum error :",analytic[int(len(old_u)/2)]-old_u[int(len(old_u)/2)])
print('---------------------------')
print("Total time :" ,time.time()-start , "seconds")
print('---------------------------')
#Some matplotlib job.
plt.title("Numerical Solution and Analytical solution of u''(x)=-x^2")
plt.legend([analy,numeric],["Analytic sol.","Numerical sol."])
plt.xlabel("x values")
plt.ylabel("u(x) values")
plt.show()



